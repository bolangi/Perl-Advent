Author: Joel Roth <joelz@pobox.com>
Title: Trimming audio files with Audio::Nama
Topic: Audio::Nama

=encoding utf8

=head2 Our task

We want to remove undesired parts of an audio file,
such as various info breaks during a radio play. Stated
differently, we want to extract relevant parts of an audio
file, and stitch them together into a new file. 

=head2 Our hammer

To do this, we install L<Ecasound|https://ecasound.seul.org/ecasound/>, a general-purpose audio
engine and L<Audio::Nama>, which configures Ecasound to perform
the recording, playback or other tasks at hand. 

We also need git, which Nama uses to manage project state,
provide for branching, undo, etc.

The first run of C<nama> creates a C<$HOME/nama> directory for 
project files and a configuration file C<$HOME/.namarc>. 

Nama defaults to linux conventions: that you'll be recording
or listening from the default ALSA soundcard device, 
usually your computer's built-in soundcard. You can
change this setting in C<namarc>.  

=head2 Create a new project, add a track and import an audio file

We'll create a new project called 'christmas'.

C<$ nama -c christmas>

We get a startup banner, then this empty track listing:
 
	 No. Name       Requested  Status  Source                Destination   Vol   Pan
	===============================================================================
	  1  Main                  MON     Main bus              CH 1/2        100    50
	  2  Mixdown               OFF     track Main            --             --    --

	nama christmas Mixdown >

In the prompt, 'christmas' is the project, 'Mixdown', the current track. 

We create a separate track to accommodate our audio file,
then import this file.

	nama christmas Mixdown > add carol
	nama christmas carol > import ~/music/christmas-carol.mp3

	format: s16_le,2,12000
	importing /home/jroth/music/christmas-carol.mp3 as /home/jroth/nama/christmas/.wav/carol_1.wav, converting to s16_le,2,44100,i

	 No. Name       Requested  Status  Source                Destination   Vol   Pan
	===============================================================================
	  1  Main                  MON     Main bus              CH 1/2        100    50
	  2  Mixdown               OFF     track Main            --             --    --
	  3  carol                 PLAY    carol_1.wav           Main bus      100    50

In the track listing above we see that track 'carol' with
source 'carol_1.wav' is set to PLAY. The output of 'carol'
feeds the 'Main' track. 'Main' serves as the master fader.
with output to the sound card: a typical mixer
configuration.

We can now press SPACE to start/stop playback. 

=head2 Define our clips

We will use a specialized type of bus called a 'sequence' to
stitch together clips from our radio play. First we need
to mark the beginning and end of each clip we want to
keep.

We do that by listening to the track and using the
C<toggle-clip> command (bound to the F1 key) to 
mark clip starts and ends. 

After some trial and error, we have the correct marks.
In this example: four five-minute sections of content
separated by 40-second breaks.

	nama christmas carol > list-marks
	
	0 40.0 clip-start-0020
	1 340.0 clip-end-0021
	2 380.0 clip-start-0022
	3 680.0 clip-end-0023
	4 720.0 clip-start-0024
	5 1020.0 clip-end-0025
	6 1060.0 clip-start-0026
	*7 1360.0 clip-end-0027


=head2 The final gathering

We can now assemble our clips.

	nama christmas carol > gather

	 No. Name       Requested  Status  Source                Destination   Vol   Pan
	===============================================================================
	  1  Main                  MON     Main bus              CH 1/2        100    50
	  2  Mixdown               OFF     track Main            --             --    --
	  3  carol                 MON     carol sequence        Main bus      100    50

Note that the source for track 3 has changed from C<carol_1.wav> to
C<carol sequence>.
 
Having listened to the output and resolved any hiccups,
we are ready to render it to an audio file.

	nama christmas carol > mixdown
	Enabling mixdown to file

	 No. Name       Requested  Status  Source                Destination   Vol   Pan
	===============================================================================
	  1  Main                  MON     Main bus              Mixdown       100    50
	  2  Mixdown               REC v1  Main                  --             --    --
	  3  carol                 MON     carol sequence        Main bus      100    50

	Now at: 0:00
	Engine is ready.
	Press SPACE to start the mixdown.

	Engine is running
	Engine is finished at 16:27

	nama christmas carol > recorded: Mixdown_1.wav
	Setting mixdown playback mode.

	 No. Name       Requested  Status  Source                Destination   Vol   Pan
	===============================================================================
	  1  Main                  OFF     Main bus              --            100    50
	  2  Mixdown               PLAY    Mixdown_1.wav         --             --    --
	  3  carol            MON  OFF     carol sequence        --            100    50

The mixdown step also generates ogg and mp3 encodings with
oggenc and lame, respectively, if desired. These files
appear in the project directory:

C<~/nama/christmas/christmas_1.mp3> 
C<~/nama/christmas/christmas_1.ogg>  
C<~/nama/christmas/christmas_1.wav> is a symlink to C<~/nama/christmas/.wav/Mixdown_1.wav>  

=head2 How the sausage is made

=head3 Basic mixer configuration

Each time a change in track status occurs, Nama generates a
I<chain setup>, which defines an Ecasound audio network. 

Let's start with the mixer configuration when we imported
the audio file. 

	 
	 No. Name       Requested  Status  Source                Destination   Vol   Pan
	===============================================================================
	  1  Main                  MON     Main bus              CH 1/2        100    50
	  2  Mixdown               OFF     track Main            --             --    --
	  3  carol                 PLAY    carol_1.wav           Main bus      100    50

This is the corresponding chain setup:
	
	nama christmas carol > chains

	# audio inputs

	-a:1 -f:s16_le,16,44100,i -i:loop,Main_in
	-a:3 -f:s16_le,2,44100 -i:/home/jroth/nama/christmas/.wav/carol_1.wav

	# audio outputs

	-a:1 -o:alsa,default
	-a:3 -f:s16_le,16,44100,i -o:loop,Main_in

Above we have two chains, labeled C<1>, and C<3>,
corresponding to our tracks 'Main' and 'carol'.

Chain C<3> reads C<carol_1.wav> and sends its output to loop
device C<Main_in>.  Chain C<1> read the stream from
C<Main_in> and supplies it to the soundcard.

=head3 Chain setup graph

A chain setup is made of signal-processing chains--edges in
the processing graph--and loop devices, which are nodes.
Each chain has one input and one output.  Chains can
terminate at an audio file, a sound device or a loop device.
A loop device is a buffer stage that can sum the signal from
one or more chains. It supplies the sum to another chain (or
possibly multiple chains.) A loop device with its sources
and an output chain can represent a mixer or bus. 

=head3 Debug output

By starting Nama with the C<-L ChainSetup> logging option,
we can see the steps from Nama's representation of the
routing graph to the final chain setup. Initially, tracks
in the graph are allowed to connect directly. Then the graph
is simplified. Dead branches are removed. Finally, loop
devices are introduced between tracks. I only include the
graph where it changes.

	[1513] ChainSetup  (L 106) Graph after bus routing:
	wav_in-carol, carol-Main

	[1514] ChainSetup  (L 111) Graph after aux sends:
	[1514] ChainSetup  (L 114) Graph with paths from Main:
	wav_in-carol, carol-Main, Main-soundcard_out

	[1514] ChainSetup  (L 117) Graph with mixdown mods:
	[1514] ChainSetup  (L 216) Graph after simplify_send_routing:
	[1514] ChainSetup  (L 218) Graph after remove_out_of_bounds_tracks:
	[1514] ChainSetup  (L 220) Graph after recursively_remove_inputless_tracks:
	[1515] ChainSetup  (L 222) Graph after recursively_remove_outputless_tracks:
	[1515] ChainSetup  (L 122) Graph after pruning unterminated branches:
	[1515] ChainSetup  (L 126) Graph after adding loop devices:
	wav_in-carol, carol-Main_in, Main_in-Main, Main-soundcard_out

	[1515] ChainSetup  (L 130) Graph with inserts:

So this is our final graph:

	wav_in-carol, carol-Main_in, Main_in-Main, Main-soundcard_out

Then we get a dump showing four IO objects
derived from the graph. These generate the input and
output terms for the two chains. There are different classes for
each type of term.

	bless( { 
	  chain_id_ => 3, 
	  endpoint_ => "wav_in", 
	  track_ => "carol",   
	}, 'Audio::Nama::IO::from_wav' ) 
						   
	bless( {               
	  chain_id_ => 1,      
	  endpoint_ => "soundcard_out", 
	  track_ => "Main",    
	}, 'Audio::Nama::IO::to_alsa_soundcard_device' ) 
						   
	bless( {               
	  chain_id_ => 3,      
	  device_id_ => "loop,Main_in", 
	  endpoint_ => "Main_in", 
	  track_ => "carol",   
	}, 'Audio::Nama::IO::to_loop' ) 
						   
	bless( {               
	  chain_id_ => 1,      
	  device_id_ => "loop,Main_in", 
	  endpoint_ => "Main_in", 
	  track_ => "Main",    
	}, 'Audio::Nama::IO::from_loop' ) 

These classes provide methods that can be overridden by
field values annotated on the graph edges or graph nodes.
Any other methods needed in generating the chain setup file
are proxied from the IO object back to the parent track.

=head3 Assembling our audio clips

We'll look at the project after we issued the C<gather>
command and are ready to listen to the sequenced clips.

If we show hidden tracks, we see our four clips each represented as a track.
The source for each is the same audio file.

	nama christmas carol > sha # show all tracks

	 No. Name       Requested  Status  Source                Destination   Vol   Pan
	===============================================================================
	  1  Main                  MON     Main bus              CH 1/2        100    50
	  2  Mixdown               OFF     track Main            --             --    --
	  3  carol                 MON     carol sequence        Main bus      100    50
	  4  carol-1-carol-v       PLAY    carol_1.wav           carol sequen  100    50
	  5  carol-2-carol-v       PLAY    carol_1.wav           carol sequen  100    50
	  6  carol-3-carol-v       PLAY    carol_1.wav           carol sequen  100    50
	  7  carol-4-carol-v       PLAY    carol_1.wav           carol sequen  100    50

In the chain setup below we see that C<select> and C<playat> terms
are used in the inputs to define a region of the audio file and play it 
with a given delay. The values were generated from our list
of marks.

	nama christmas carol > chains

	# audio inputs

	-a:1 -f:s16_le,16,44100,i -i:loop,Main_in
	-a:3 -f:s16_le,16,44100,i -i:loop,carol_in
	-a:4 -f:s16_le,2,44100 -i:select,40,300,/home/jroth/nama/christmas/.wav/carol_1.wav
	-a:5 -f:s16_le,2,44100 -i:playat,300,select,380,300,/home/jroth/nama/christmas/.wav/carol_1.wav
	-a:6 -f:s16_le,2,44100 -i:playat,600,select,720,300,/home/jroth/nama/christmas/.wav/carol_1.wav
	-a:7 -f:s16_le,2,44100 -i:playat,900,select,1060,300,/home/jroth/nama/christmas/.wav/carol_1.wav

	# audio outputs

	-a:1 -o:alsa,default
	-a:3 -f:s16_le,16,44100,i -o:loop,Main_in
	-a:4,5,6,7 -f:s16_le,16,44100,i -o:loop,carol_in

The mixdown configuration is the same, with the output of chain 1 directed to a file. 

=head2 Thanks for reading!

There are many other things you can do with Nama but that's all for today!

=head2 Showcase

Jeanette Claassen has produced a large number of
L<original|https://www.youtube.com/@jeanette_c3896/videos>
L<songs|https://juliencoder.de/nama> using Nama in
combination with various other music software and hardware.
She began recording music using Ecasound and migrated to
Nama as it became sufficiently featureful.

=head2 Notable dependencies

 L<Git::Repository>: Manage project history, branching, undo
 L<Log::Log4perl>: Logging, debugging
 L<Parse::RecDescent>: Command language parser
 L<Object::Tiny>: Accessor generator
 L<Role::Tiny>: Breaking up large classes
 L<Term::ReadLine::Gnu>: Terminal support, tab completion, history
 L<Term::TermKey>: Hotkey mappings
 L<Graph>: Representing, traversing and transforming the signal processing network
 L<AnyEvent>: Event loop
 L<Tk>: GUI, available with the -g option, use at your own risk!
 L<Data::Section::Simple>: Store and access sections within the __DATA__ block
 L<Data::Dumper::Concise>, tho I would now recommend L<Data::Printer>.
 L<Memoize>: Turn expensive, redundant calculations into cheap lookups
 L<Devel::NYTProf>: Profiling to find and solve bottlenecks
